local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")

local forkion = Players.LocalPlayer
local forkionGui = forkion:WaitForChild("PlayerGui")
local forkionEvent = ReplicatedStorage.Events.Grab
local workspace = game:GetService("Workspace")

local FORKION_CONFIG = {
    REACH_RADIUS = 10,
    MIN_GRAB_DISTANCE = 1,
    MAX_GRAB_DISTANCE = 10,
    GRAB_COOLDOWN = 0.00,
    UPDATE_THRESHOLD = 1/60,
    SMART_TARGETING_WEIGHT = 0.8,
    ANGLE_WEIGHT = 0.4,
    FOV_THRESHOLD = 45,
    PREDICTION_FACTOR = 0.35,
    TARGET_MEMORY_TIME = 0.3
}

local ForkionState = {
    lastTarget = nil,
    lastTargetTime = 0,
    mousePosition = Vector2.new(),
    lastMindTime = 0
}

local function forkionPredictTargetPosition(forkionTarget)
    local forkionCharacter = forkionTarget.Character
    if not forkionCharacter then return nil end
    local forkionRoot = forkionCharacter:FindFirstChild("HumanoidRootPart")
    if not forkionRoot then return nil end
    local forkionPos = forkionRoot.Position
    local forkionVelocity = forkionRoot.Velocity
    local forkionAcceleration = forkionRoot.AssemblyLinearVelocity - forkionVelocity
    return forkionPos + (forkionVelocity * FORKION_CONFIG.PREDICTION_FACTOR) + (forkionAcceleration * FORKION_CONFIG.PREDICTION_FACTOR * 0.5)
end

local function forkionCalculateTargetScore(forkionTarget)
    local forkionCharacter = forkionTarget.Character
    if not forkionCharacter then return -1 end
    local forkionRoot = forkionCharacter:FindFirstChild("HumanoidRootPart")
    if not forkionRoot then return -1 end
    local forkionPlayerRoot = forkion.Character and forkion.Character:FindFirstChild("HumanoidRootPart")
    if not forkionPlayerRoot then return -1 end
    local forkionDistance = (forkionRoot.Position - forkionPlayerRoot.Position).Magnitude
    if forkionDistance > FORKION_CONFIG.REACH_RADIUS then return -1 end
    local forkionDistanceScore = 1 - (forkionDistance / FORKION_CONFIG.REACH_RADIUS)
    local forkionCamera = workspace.CurrentCamera
    local forkionScreenPoint = forkionCamera:WorldToScreenPoint(forkionRoot.Position)
    local forkionAngleToMouse = (Vector2.new(forkionScreenPoint.X, forkionScreenPoint.Y) - ForkionState.mousePosition).Magnitude
    local forkionAngleScore = 1 - math.min(forkionAngleToMouse / 300, 1)
    local forkionLookVector = forkionCamera.CFrame.LookVector
    local forkionTargetVector = (forkionRoot.Position - forkionCamera.CFrame.Position).Unit
    local forkionDotProduct = forkionLookVector:Dot(forkionTargetVector)
    local forkionDirectionScore = (forkionDotProduct + 1) / 2
    return (forkionDistanceScore * FORKION_CONFIG.SMART_TARGETING_WEIGHT) + (forkionAngleScore * FORKION_CONFIG.ANGLE_WEIGHT) + (forkionDirectionScore * 0.3)
end

local function forkionCreateTargetingEffect(forkionTarget)
    local forkionCharacter = forkionTarget.Character
    if not forkionCharacter then return end
    local forkionExistingHighlight = forkionCharacter:FindFirstChild("ForkionHighlight")
    if forkionExistingHighlight then forkionExistingHighlight:Destroy() end
    local forkionHighlight = Instance.new("Highlight")
    forkionHighlight.Name = "ForkionHighlight"
    forkionHighlight.FillColor = Color3.fromRGB(0, 255, 100)
    forkionHighlight.OutlineColor = Color3.fromRGB(255, 255, 255)
    forkionHighlight.FillTransparency = 0.7
    forkionHighlight.OutlineTransparency = 0
    forkionHighlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    forkionHighlight.Parent = forkionCharacter
    local forkionTweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, 0, true)
    local forkionTween = TweenService:Create(forkionHighlight, forkionTweenInfo, {FillTransparency = 0.3, OutlineTransparency = 0.3})
    forkionTween:Play()
    game:GetService("Debris"):AddItem(forkionHighlight, 0.3)
end

local function forkionGetManualTarget()
    local forkionCharacter = forkion.Character
    local forkionRoot = forkionCharacter and forkionCharacter:FindFirstChild("HumanoidRootPart")
    if not forkionRoot then return nil end
    local forkionBestTarget = nil
    local forkionBestScore = -1
    local forkionPlayerList = Players:GetPlayers()
    for _, forkionTarget in ipairs(forkionPlayerList) do
        if forkionTarget == forkion then continue end
        local forkionScore = forkionCalculateTargetScore(forkionTarget)
        if forkionScore > forkionBestScore then
            forkionBestScore = forkionScore
            forkionBestTarget = forkionTarget
        end
    end
    if forkionBestTarget then
        ForkionState.lastTarget = forkionBestTarget
        ForkionState.lastTargetTime = tick()
    elseif tick() - ForkionState.lastTargetTime < FORKION_CONFIG.TARGET_MEMORY_TIME then
        return ForkionState.lastTarget
    end
    return forkionBestTarget
end

local function forkionPerformMindControl()
    local forkionCurrentTime = tick()
    if forkionCurrentTime - ForkionState.lastMindTime < FORKION_CONFIG.GRAB_COOLDOWN then return end
    ForkionState.lastMindTime = forkionCurrentTime
    local forkionTarget = forkionGetManualTarget()
    if not forkionTarget then return end
    local forkionPredictedPos = forkionPredictTargetPosition(forkionTarget)
    if not forkionPredictedPos then return end
    local forkionCharacter = forkionTarget.Character
    local forkionTorso = forkionCharacter and (forkionCharacter:FindFirstChild("Torso") or forkionCharacter:FindFirstChild("UpperTorso"))
    if not forkionTorso then return end
    forkionCreateTargetingEffect(forkionTarget)
    local forkionArgs = {
        [1] = forkionTorso,
        [2] = "Mind Control",
        [3] = forkionPredictedPos,
        [4] = forkionTorso.CFrame
    }
    forkionEvent:FireServer(unpack(forkionArgs))
end

local function forkionInitMindSystem()
    local forkionExistingGui = forkionGui:FindFirstChild("mindmobile")
    if forkionExistingGui then forkionExistingGui:Destroy() end
    local forkionScreenGui = Instance.new("ScreenGui")
    forkionScreenGui.Name = "mindmobile"
    forkionScreenGui.ResetOnSpawn = false
    forkionScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    forkionScreenGui.Parent = forkionGui
    local forkionButtonFrame = Instance.new("Frame")
    forkionButtonFrame.Name = "ForkionButtonFrame"
    forkionButtonFrame.Size = UDim2.new(0, 85, 0, 85)
    forkionButtonFrame.Position = UDim2.new(1, -220, 0, 150)
    forkionButtonFrame.BackgroundTransparency = 1
    forkionButtonFrame.Parent = forkionScreenGui
    local forkionButton = Instance.new("TextButton")
    forkionButton.Name = "ForkionButton"
    forkionButton.Size = UDim2.new(1, -10, 1, -10)
    forkionButton.Position = UDim2.new(0, 5, 0, 5)
    forkionButton.Text = "MIND"
    forkionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    forkionButton.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
    forkionButton.BorderSizePixel = 0
    forkionButton.AutoButtonColor = true
    forkionButton.Font = Enum.Font.GothamBold
    forkionButton.TextSize = 22
    forkionButton.Parent = forkionButtonFrame
    local forkionUICorner = Instance.new("UICorner")
    forkionUICorner.CornerRadius = UDim.new(0, 12)
    forkionUICorner.Parent = forkionButton
    local forkionUIGradient = Instance.new("UIGradient")
    forkionUIGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 100)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(0, 150, 60))
    })
    forkionUIGradient.Parent = forkionButton
    forkionButton.MouseEnter:Connect(function()
        TweenService:Create(forkionButton, TweenInfo.new(0.3), {BackgroundColor3 = Color3.fromRGB(60, 60, 60)}):Play()
    end)
    forkionButton.MouseLeave:Connect(function()
        TweenService:Create(forkionButton, TweenInfo.new(0.3), {BackgroundColor3 = Color3.fromRGB(45, 45, 45)}):Play()
    end)
    forkionButton.MouseButton1Down:Connect(function()
        TweenService:Create(forkionButton, TweenInfo.new(0.1), {Size = UDim2.new(0.95, -10, 0.95, -10), Position = UDim2.new(0.025, 5, 0.025, 5)}):Play()
    end)
    forkionButton.MouseButton1Up:Connect(function()
        TweenService:Create(forkionButton, TweenInfo.new(0.1), {Size = UDim2.new(1, -10, 1, -10), Position = UDim2.new(0, 5, 0, 5)}):Play()
    end)
    local function forkionUpdateMousePosition(forkionInput)
        if forkionInput.UserInputType == Enum.UserInputType.MouseMovement then
            ForkionState.mousePosition = Vector2.new(forkionInput.Position.X, forkionInput.Position.Y)
        end
    end
    UserInputService.InputChanged:Connect(forkionUpdateMousePosition)
    forkionButton.MouseButton1Click:Connect(forkionPerformMindControl)
    local forkionButtonPressTime = 0
    local forkionDragging = false
    local forkionDragInput, forkionDragStart, forkionStartPos
    local function forkionUpdate(forkionInput)
        local forkionDelta = forkionInput.Position - forkionDragStart
        forkionButtonFrame.Position = UDim2.new(forkionStartPos.X.Scale, forkionStartPos.X.Offset + forkionDelta.X, forkionStartPos.Y.Scale, forkionStartPos.Y.Offset + forkionDelta.Y)
    end
    forkionButton.InputBegan:Connect(function(forkionInput)
        if forkionInput.UserInputType == Enum.UserInputType.MouseButton1 or forkionInput.UserInputType == Enum.UserInputType.Touch then
            forkionButtonPressTime = tick()
            forkionDragging = false
            forkionDragStart = forkionInput.Position
            forkionStartPos = forkionButtonFrame.Position
            forkionInput.Changed:Connect(function()
                if forkionInput.UserInputState == Enum.UserInputState.End then
                    forkionDragging = false
                end
            end)
        end
    end)
    forkionButton.InputChanged:Connect(function(forkionInput)
        if forkionInput.UserInputType == Enum.UserInputType.MouseMovement or forkionInput.UserInputType == Enum.UserInputType.Touch then
            if tick() - forkionButtonPressTime >= 2 then
                forkionDragInput = forkionInput
                forkionDragging = true
            end
        end
    end)
    UserInputService.InputChanged:Connect(function(forkionInput)
        if forkionInput == forkionDragInput and forkionDragging then
            forkionUpdate(forkionInput)
        end
    end)
end

spawn(function()
    wait(1)
    local forkionSuccess, forkionErr = pcall(forkionInitMindSystem)
    if not forkionSuccess then
        warn("Erro ao iniciar mindmobile:", forkionErr)
    end
end)
